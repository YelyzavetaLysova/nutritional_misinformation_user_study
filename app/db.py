"""
Database module for the nutritional misinformation survey app.
Provides functions to interact with the SQLite database.
"""

import os
import json
import sqlite3
import logging
from datetime import datetime
from typing import Dict, List, Any, Optional

# Configure logging
logger = logging.getLogger(__name__)

# Database path
DB_PATH = "data/survey.db"

def init_db():
    """
    Initialize the database and create tables if they don't exist.
    """
    os.makedirs(os.path.dirname(DB_PATH), exist_ok=True)
    
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    
    # Create tables
    cursor.executescript("""
    CREATE TABLE IF NOT EXISTS participants (
        participant_id TEXT PRIMARY KEY,
        prolific_pid TEXT,
        study_id TEXT,
        session_id TEXT,
        start_time TEXT,
        completed_time TEXT,
        completed BOOLEAN,
        time_spent_minutes REAL,
        age TEXT,
        gender TEXT,
        education TEXT,
        nationality TEXT
    );
    
    CREATE TABLE IF NOT EXISTS recipe_evaluations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        participant_id TEXT,
        eval_number INTEGER,
        recipe_id INTEGER,
        recipe_name TEXT,
        recipe_category TEXT,
        clarity_rating INTEGER,             -- How would you rate the clarity of this recipe?
        tastiness_rating INTEGER,           -- How tasty does this recipe seem?
        completeness_rating INTEGER,        -- How complete is this recipe?
        correctness_rating INTEGER,         -- How correct does this recipe seem?
        ingredients_correctness INTEGER,    -- How correct are the ingredients?
        instructions_correctness INTEGER,   -- How correct are the instructions?
        nutrition_correctness INTEGER,      -- How correct is the nutrition information?
        feasibility_rating INTEGER,         -- How feasible would it be for you to make this recipe?
        quality_rating INTEGER,             -- How would you rate the overall quality of this recipe?
        would_make TEXT,                    -- Would you make this recipe?
        comments TEXT,                      -- Any comments about this recipe?
        FOREIGN KEY (participant_id) REFERENCES participants (participant_id)
    );
    
    CREATE TABLE IF NOT EXISTS post_surveys (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        participant_id TEXT,
        cooking_skills INTEGER,             -- How would you rate your cooking skills?
        new_recipe_frequency TEXT,          -- How often do you cook new recipes?
        preferred_source TEXT,              -- What's most important to you when deciding whether to try a recipe?
        cooking_frequency TEXT,             -- How often do you cook meals at home?
        trust_human_recipes INTEGER,        -- How much would you trust recipes created by human authors?
        trust_ai_recipes INTEGER,           -- How much would you trust recipes generated by AI tools (e.g., ChatGPT)?
        ai_usage TEXT,                      -- How frequently do you use AI platforms like ChatGPT, DeepSeek, or Gemini Assistant?
        comments TEXT,                      -- Any comments about what makes a recipe feasible for you to cook?
        FOREIGN KEY (participant_id) REFERENCES participants (participant_id)
    );
    """)
    
    conn.commit()
    conn.close()
    logger.info("Database initialized")


def save_participant(participant_data: Dict[str, Any]):
    """
    Save or update a participant and their responses to the database.
    """
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    
    try:
        participant_id = participant_data.get("id")
        
        # Check if participant already exists
        cursor.execute("SELECT participant_id FROM participants WHERE participant_id = ?", 
                      (participant_id,))
        existing = cursor.fetchone()
        
        # Calculate time spent if available
        time_spent_minutes = None
        start_time = participant_data.get("start_time")
        completed_time = participant_data.get("responses", {}).get("completed_time")
        
        if start_time and completed_time:
            try:
                start_dt = datetime.fromisoformat(start_time)
                end_dt = datetime.fromisoformat(completed_time)
                time_spent_seconds = (end_dt - start_dt).total_seconds()
                time_spent_minutes = round(time_spent_seconds / 60, 2)
            except Exception as e:
                logger.warning(f"Could not calculate time spent: {e}")
        
        # Get demographics and Prolific info
        demographics = participant_data.get("responses", {}).get("demographics", {})
        prolific_info = participant_data.get("responses", {}).get("prolific_info", {})
        
        # Insert or update participant data
        if existing:
            cursor.execute("""
            UPDATE participants SET 
                prolific_pid = ?,
                study_id = ?,
                session_id = ?,
                start_time = ?,
                completed_time = ?,
                completed = ?,
                time_spent_minutes = ?,
                age = ?,
                gender = ?,
                education = ?,
                nationality = ?
            WHERE participant_id = ?
            """, (
                prolific_info.get("prolific_pid"),
                prolific_info.get("study_id"),
                prolific_info.get("session_id"),
                start_time,
                completed_time,
                participant_data.get("completed", False),
                time_spent_minutes,
                demographics.get("age"),
                demographics.get("gender"),
                demographics.get("education"),
                demographics.get("nationality"),
                participant_id
            ))
            logger.info(f"Updated participant {participant_id} in database")
        else:
            cursor.execute("""
            INSERT INTO participants 
            (participant_id, prolific_pid, study_id, session_id, start_time, completed_time, completed, time_spent_minutes,
             age, gender, education, nationality)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                participant_id,
                prolific_info.get("prolific_pid"),
                prolific_info.get("study_id"),
                prolific_info.get("session_id"),
                start_time,
                completed_time,
                participant_data.get("completed", False),
                time_spent_minutes,
                demographics.get("age"),
                demographics.get("gender"),
                demographics.get("education"),
                demographics.get("nationality")
            ))
            logger.info(f"Added participant {participant_id} to database")
        
        # Save recipe evaluations
        for i in range(1, 6):
            eval_key = f"recipe_eval_{i}"
            if eval_key in participant_data.get("responses", {}):
                eval_data = participant_data["responses"][eval_key]
                
                # Check if evaluation already exists
                cursor.execute("""
                SELECT id FROM recipe_evaluations 
                WHERE participant_id = ? AND eval_number = ?
                """, (participant_id, i))
                
                existing = cursor.fetchone()
                
                # Handle both old and new formats (credibility_rating vs. clarity_rating)
                clarity_rating = eval_data.get("clarity_rating", eval_data.get("credibility_rating"))
                
                if existing:
                    cursor.execute("""
                    UPDATE recipe_evaluations SET
                        recipe_id = ?,
                        recipe_name = ?,
                        recipe_category = ?,
                        clarity_rating = ?,
                        tastiness_rating = ?,
                        completeness_rating = ?,
                        correctness_rating = ?,
                        ingredients_correctness = ?,
                        instructions_correctness = ?,
                        nutrition_correctness = ?,
                        feasibility_rating = ?,
                        quality_rating = ?,
                        would_make = ?,
                        comments = ?
                    WHERE participant_id = ? AND eval_number = ?
                    """, (
                        eval_data.get("recipe_id"),
                        eval_data.get("recipe_name"),
                        eval_data.get("recipe_category"),
                        clarity_rating,
                        eval_data.get("tastiness_rating"),
                        eval_data.get("completeness_rating"),
                        eval_data.get("correctness_rating"),
                        eval_data.get("ingredients_correctness"),
                        eval_data.get("instructions_correctness"),
                        eval_data.get("nutrition_correctness"),
                        eval_data.get("feasibility_rating"),
                        eval_data.get("quality_rating"),
                        eval_data.get("would_make"),
                        eval_data.get("comments", ""),
                        participant_id,
                        i
                    ))
                else:
                    cursor.execute("""
                    INSERT INTO recipe_evaluations
                    (participant_id, eval_number, recipe_id, recipe_name, recipe_category,
                     clarity_rating, tastiness_rating, completeness_rating,
                     correctness_rating, ingredients_correctness, instructions_correctness,
                     nutrition_correctness, feasibility_rating, quality_rating, would_make, comments)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                    """, (
                        participant_id,
                        i,
                        eval_data.get("recipe_id"),
                        eval_data.get("recipe_name"),
                        eval_data.get("recipe_category"),
                        clarity_rating,
                        eval_data.get("tastiness_rating"),
                        eval_data.get("completeness_rating"),
                        eval_data.get("correctness_rating"),
                        eval_data.get("ingredients_correctness"),
                        eval_data.get("instructions_correctness"),
                        eval_data.get("nutrition_correctness"),
                        eval_data.get("feasibility_rating"),
                        eval_data.get("quality_rating"),
                        eval_data.get("would_make"),
                        eval_data.get("comments", "")
                    ))
        
        # Save post survey data
        if "post_survey" in participant_data.get("responses", {}):
            post_data = participant_data["responses"]["post_survey"]
            
            # Check if post survey already exists
            cursor.execute("""
            SELECT id FROM post_surveys WHERE participant_id = ?
            """, (participant_id,))
            
            existing = cursor.fetchone()
            
            # Handle both old and new formats (ai_knowledge vs. ai_usage)
            ai_usage = post_data.get("ai_usage", post_data.get("ai_knowledge"))
            
            if existing:
                cursor.execute("""
                UPDATE post_surveys SET
                    cooking_skills = ?,
                    new_recipe_frequency = ?,
                    preferred_source = ?,
                    cooking_frequency = ?,
                    trust_human_recipes = ?,
                    trust_ai_recipes = ?,
                    ai_usage = ?,
                    comments = ?
                WHERE participant_id = ?
                """, (
                    post_data.get("cooking_skills"),
                    post_data.get("new_recipe_frequency"),
                    post_data.get("preferred_source"),
                    post_data.get("cooking_frequency"),
                    post_data.get("trust_human_recipes"),
                    post_data.get("trust_ai_recipes"),
                    ai_usage,
                    post_data.get("comments", ""),
                    participant_id
                ))
            else:
                cursor.execute("""
                INSERT INTO post_surveys
                (participant_id, cooking_skills, new_recipe_frequency, preferred_source,
                 cooking_frequency, trust_human_recipes, trust_ai_recipes, ai_usage, comments)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    participant_id,
                    post_data.get("cooking_skills"),
                    post_data.get("new_recipe_frequency"),
                    post_data.get("preferred_source"),
                    post_data.get("cooking_frequency"),
                    post_data.get("trust_human_recipes"),
                    post_data.get("trust_ai_recipes"),
                    ai_usage,
                    post_data.get("comments", "")
                ))
        
        conn.commit()
        logger.info(f"Successfully saved all data for participant {participant_id}")
        return True
        
    except Exception as e:
        conn.rollback()
        logger.error(f"Error saving participant data: {e}")
        return False
    finally:
        conn.close()


def import_existing_data():
    """
    Import existing data from JSON files into the database.
    """
    import glob
    import json
    
    # Find all participant JSON files
    json_files = glob.glob("data/responses/p_*.json")
    logger.info(f"Found {len(json_files)} participant JSON files")
    
    imported_count = 0
    for json_file in json_files:
        try:
            with open(json_file, 'r') as f:
                data = json.load(f)
            
            participant_id = os.path.basename(json_file).replace('.json', '')
            
            # Create a participant data structure that matches what our save function expects
            participant_data = {
                "id": participant_id,
                "start_time": data.get("start_time"),
                "completed": "completed_time" in data,
                "responses": data,
                "selected_recipes": []
            }
            
            # Extract recipe IDs if available
            for i in range(1, 6):
                eval_key = f"recipe_eval_{i}"
                if eval_key in data and "recipe_id" in data[eval_key]:
                    participant_data["selected_recipes"].append(data[eval_key]["recipe_id"])
            
            # Save to database
            if save_participant(participant_data):
                imported_count += 1
                
        except Exception as e:
            logger.error(f"Error importing {json_file}: {e}")
    
    logger.info(f"Successfully imported {imported_count} participants to the database")
    return imported_count


def get_participant_data(participant_id: str) -> Optional[Dict]:
    """
    Retrieve a participant's data from the database.
    Returns None if participant doesn't exist.
    """
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row  # This enables column access by name
    cursor = conn.cursor()
    
    try:
        # Get participant data
        cursor.execute("""
        SELECT * FROM participants WHERE participant_id = ?
        """, (participant_id,))
        
        participant_row = cursor.fetchone()
        if not participant_row:
            return None
        
        # Convert row to dict
        participant = dict(participant_row)
        
        # Get recipe evaluations
        cursor.execute("""
        SELECT * FROM recipe_evaluations 
        WHERE participant_id = ? 
        ORDER BY eval_number
        """, (participant_id,))
        
        evaluations = [dict(row) for row in cursor.fetchall()]
        
        # Get post survey
        cursor.execute("""
        SELECT * FROM post_surveys 
        WHERE participant_id = ?
        """, (participant_id,))
        
        post_survey = cursor.fetchone()
        if post_survey:
            post_survey = dict(post_survey)
        
        # Combine all data
        result = {
            "participant": participant,
            "recipe_evaluations": evaluations,
            "post_survey": post_survey
        }
        
        return result
        
    except Exception as e:
        logger.error(f"Error retrieving participant data: {e}")
        return None
    finally:
        conn.close()


def export_to_csv():
    """
    Export all data from the database to CSV files for compatibility
    with the existing analysis scripts.
    """
    import csv
    import pandas as pd
    import os
    
    os.makedirs("data/normalized", exist_ok=True)
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    
    try:
        # Export participants
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM participants")
        participants = [dict(row) for row in cursor.fetchall()]
        
        if participants:
            df = pd.DataFrame(participants)
            df.to_csv("data/normalized/participants.csv", index=False)
            logger.info(f"Exported {len(participants)} participants to CSV")
        
        # Export recipe evaluations
        cursor.execute("SELECT * FROM recipe_evaluations")
        evaluations = [dict(row) for row in cursor.fetchall()]
        
        if evaluations:
            df = pd.DataFrame(evaluations)
            df.to_csv("data/normalized/recipe_evaluations.csv", index=False)
            logger.info(f"Exported {len(evaluations)} recipe evaluations to CSV")
        
        # Export post surveys
        cursor.execute("SELECT * FROM post_surveys")
        surveys = [dict(row) for row in cursor.fetchall()]
        
        if surveys:
            df = pd.DataFrame(surveys)
            df.to_csv("data/normalized/post_survey.csv", index=False)
            logger.info(f"Exported {len(surveys)} post surveys to CSV")
        
        return True
        
    except Exception as e:
        logger.error(f"Error exporting data to CSV: {e}")
        return False
    finally:
        conn.close()
